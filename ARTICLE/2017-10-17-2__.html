<!DOCTYPE html>
<html>
<head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width"><link rel="stylesheet" type="text/css" media="all" href="../css/article_styles.css"><script type='text/x-mathjax-config'>  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script><script type='text/javascript' src='http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></head>
<body><div class='content'><h1 id="2017-10-17-2 Android 学习笔记(2) 事件回调机制">2017-10-17-2 Android 学习笔记(2) 事件回调机制</h1>

<h2 id="1、Android事件的传递顺序">1、Android事件的传递顺序</h2>

<table>
	<th>类别</th><th>例子</th>
	<tr><td>事件监听器</td><td>在new XXXListener的构造中的public boolean onKeyDown(int keyCode, KeyEvent event) </td></tr>
	<tr><td>控件自己的响应函数</td><td>在控件的构造中的public boolean onKeyDown(int keyCode, KeyEvent event)</td></tr>
	<tr><td>Activity的响应函数</td><td>在Activity的构造中的public boolean onKeyDown(int keyCode, KeyEvent event)</td></tr>
</table>

<h2 id="2、为控件设置回调函数">2、为控件设置回调函数</h2>

<h3 id="方法：">方法：</h3>

1、重载控件，重写回调函数

2、为控件安装事件监听器

<h3 id="Android可以选的部分事件回调机制">Android可以选的部分事件回调机制</h3>
<div class='citation'><p class='citationP'><br>①在该组件上触发屏幕事件: boolean onTouchEvent(MotionEvent event);<br><br>②在该组件上按下某个按钮时: boolean onKeyDown(int keyCode,KeyEvent event);<br><br>③松开组件上的某个按钮时: boolean onKeyUp(int keyCode,KeyEvent event);<br><br>④长按组件某个按钮时: boolean onKeyLongPress(int keyCode,KeyEvent event);<br><br>⑤键盘快捷键事件发生: boolean onKeyShortcut(int keyCode,KeyEvent event);<br><br>⑥在组件上触发轨迹球屏事件: boolean onTrackballEvent(MotionEvent event);<br><br>⑦当组件的焦点发生改变,和前面的6个不同,这个方法只能够在View中重写 <br>protected void onFocusChanged(boolean gainFocus, int direction, Rect previously FocusedRect)
</p></div>
<h3 id="例子">例子</h3><div class="liRank0"><li class="liRank0">重载控件</li></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>public class MyButton extends Button{  
    private static String TAG = &quot;呵呵&quot;;  
    public MyButton(Context context, AttributeSet attrs) {  
        super(context, attrs);  
    }  
  
    //重写键盘按下触发的事件  
    @Override  
    public boolean onKeyDown(int keyCode, KeyEvent event) {  
        super.onKeyDown(keyCode,event);  
        Log.i(TAG, &quot;onKeyDown方法被调用&quot;);  
        return true;  
    }  
  
    //重写弹起键盘触发的事件  
    @Override  
    public boolean onKeyUp(int keyCode, KeyEvent event) {  
        super.onKeyUp(keyCode,event);  
        Log.i(TAG,&quot;onKeyUp方法被调用&quot;);  
        return true;  
    }  
  
    //组件被触摸了  
    @Override  
    public boolean onTouchEvent(MotionEvent event) {  
        super.onTouchEvent(event);  
        Log.i(TAG,&quot;onTouchEvent方法被调用&quot;);  
        return true;  
    }  
} 
</blockquote></pre></div>


需要注意的是：当事件函数结束时，返回值为true则不会继续向外传播而会停止

<div class="liRank0"><li class="liRank0">安装监听器</li></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>Button btn=(Button)findViewById(R.id.button_signIn);
btn.setOnClickListener(new View.OnClickListener() {
		@Override
    public void onClick(View v) {
        Toast.makeText(getApplicationContext(),&quot;Sign In&quot;,Toast.LENGTH_SHORT).show();
    }
});
</blockquote></pre></div>
</div></body>
</html>
