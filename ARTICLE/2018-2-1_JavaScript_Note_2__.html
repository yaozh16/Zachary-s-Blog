<!DOCTYPE html>
<html>
<head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width"><link rel="stylesheet" type="text/css" media="all" href="../css/article_styles.css"><script type='text/x-mathjax-config'>  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script><script type='text/javascript' src='http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></head>
<body><div class='content'><h1 id="2018-2-1 JavaScript Note(2)">2018-2-1 JavaScript Note(2)</h1>
<h2 id="function">function</h2><div class="ulRank0"><ul class="ulRank0">1. 语法function [functionName] ([parameter])</ul></div><div class="ulRank0"><ul class="ulRank0">2. 语法var  [functionName] =function([parameter])</ul></div><div class="ulRank0"><ul class="ulRank0">3. 传入参数允许多于需要的函数</ul></div><div class="ulRank0"><ul class="ulRank0">4. arguments保留字可以获取参数信息<div class="liRank0"><li class="liRank0">arguments.length</li></div><div class="liRank0"><li class="liRank0">arguments[i]</li></div></ul></div><div class="ulRank0"><ul class="ulRank0">5. ...rest</ul></div>
用于保存多余的参数
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>function foo(a, b, ...rest)
</blockquote></pre></div><div class="ulRank0"><ul class="ulRank0">6. JavaScript引擎在行末自动添加分号，注意return语句</ul></div>
<h2 id="Varialble">Varialble</h2>
JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部,但不会提升变量的赋值<div class="ulRank0"><ul class="ulRank0">1. JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性</ul></div><div class="ulRank0"><ul class="ulRank0">2.  命名空间</ul></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>// 唯一的全局变量MYAPP:
var MYAPP = {};

// 其他变量:
MYAPP.name = &apos;myapp&apos;;
MYAPP.version = 1.0;

// 其他函数:
MYAPP.foo = function () {
    return &apos;foo&apos;;
};

</blockquote></pre></div><div class="ulRank0"><ul class="ulRank0">3. 用let替代var可以申明一个块级作用域的变量</ul></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>&apos;use strict&apos;;

function foo() {
    var sum = 0;
    for (let i=0; i&lt;100; i++) {
        sum += i;
    }
    // SyntaxError:
    i += 1;
}
</blockquote></pre></div><div class="ulRank0"><ul class="ulRank0">4. ES6标准引入了新的关键字const来定义常量，const与let都具有块级作用域</ul></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>&apos;use strict&apos;;

const PI = 3.14;
PI = 3; // 某些浏览器不报错，但是无效果！
PI; // 3.14
</blockquote></pre></div><div class="ulRank0"><ul class="ulRank0">5. 解构赋值</ul></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>&apos;use strict&apos;;

// 如果浏览器支持解构赋值就不会报错:
var [x, y, z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;];
// 忽略前两个元素，只对z赋值第三个元素
let [, , z] = [&apos;hello&apos;, &apos;JavaScript&apos;, &apos;ES6&apos;];
</blockquote></pre></div>
对一个对象进行解构赋值时，同样可以直接对嵌套的对象属性进行赋值，只要保证对应的层次是一致的
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>var person = {
    name: &apos;小明&apos;,
    age: 20,
    gender: &apos;male&apos;,
    passport: &apos;G-12345678&apos;,
    school: &apos;No.4 middle school&apos;,
    address: {
        city: &apos;Beijing&apos;,
        street: &apos;No.1 Road&apos;,
        zipcode: &apos;100001&apos;
    }
};
var {name, address: {city, zip}} = person;
name; // &apos;小明&apos;
city; // &apos;Beijing&apos;
zip; // undefined, 因为属性名是zipcode而不是zip
// 注意: address不是变量，而是为了让city和zip获得嵌套的address对象的属性:
address; // Uncaught ReferenceError: address is not defined

</blockquote></pre></div><div class="liRank0"><li class="liRank0">有些时候，如果变量已经被声明了，再次赋值的时候，正确的写法也会报语法错误：</li></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>// 声明变量:
var x, y;
// 解构赋值:
{x, y} = { name: &apos;小明&apos;, x: 100, y: 200};
// 语法错误: Uncaught SyntaxError: Unexpected token =
</blockquote></pre></div>
这是因为JavaScript引擎把{开头的语句当作了块处理，于是=不再合法。解决方法是用小括号括起来：
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>({x, y} = { name: &apos;小明&apos;, x: 100, y: 200});
</blockquote></pre></div>
<h2 id="Method">Method</h2>
一个函数中的this指针除了obj.func()形式之外，无论位置在什么地方，其this指针为undefined<div class="liRank0"><li class="liRank0">除非对函数对象使用apply(this_object,parameter_array)函数或者call()</li></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>function getAge() {...}
getAge.apply(xiaoming, [p1,p2]);
getAge.call(xiaoming, p1,p2);
</blockquote></pre></div>
<h4 id="map(function)">map(function)</h4>
<h4 id="reduce(function(x,y),initX)   其中initX可以不要">reduce(function(x,y),initX)   其中initX可以不要</h4>
注意使用标准函数的时候可能的默认参数
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>[&apos;1&apos;,&apos;2&apos;,&apos;3&apos;].map(parseInt);// 结果实际上是[1,NaN,NaN];
</blockquote></pre></div>
<h4 id="filter(function)">filter(function)</h4>
<h4 id="sort(function)">sort(function)</h4>
sort函数默认的将所有数字转为string再进行ascii比较，但也可以自己定义比较函数
返回值为负数,0,正数分别标识小于、等于、大于</div></body>
</html>
