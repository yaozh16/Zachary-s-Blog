<!DOCTYPE html>
<html>
<head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width"><link rel="stylesheet" type="text/css" media="all" href="../css/article_styles.css"><script type='text/x-mathjax-config'>  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script><script type='text/javascript' src='http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></head>
<body><div class='content'><h1 id="2017-11-29 Django复习">2017-11-29 Django复习</h1>

<h2 id="start">start</h2>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>django-admin startproject mysite
python manage.py runserver 0:8000
</blockquote></pre></div>
<h2 id="create app for site">create app for site</h2>
<h3 id="install">install</h3>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>#在setting.py中的INSTALLED_APPS 加入
&apos;polls.apps.pollsConfig&apos;,
</blockquote></pre></div>
<h3 id="url parser">url parser</h3>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>python manage.py startapp polls
</blockquote></pre></div>
手动添加polls/url.py用于局部url解析
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>from django.conf.urls import url
from . import views

urlpatterns = [
    url(regex=r&apos;^$&apos;, views=views.index, name=&apos;index&apos;),
]
</blockquote></pre></div>
其中
<table cellspacing='0'><tr><th> regex                                   </th><th> views                                         </th><th> name      </th></tr><tr><td> 可以使用模式匹配，作为参数传入views函数 </td><td> 响应函数，传入HttpRequest和模式匹配得到的参数 </td><td> url标识名 </td></tr></table><br>
同时修改根url解析器url.py使polls/url.py生效
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>from django.conf.urls import include, url
from django.contrib import admin

urlpatterns = [
    url(r&apos;^polls/&apos;, include(&apos;polls.urls&apos;)),
    url(r&apos;^admin/&apos;, admin.site.urls),]

</blockquote></pre></div>
其中include函数的reg不能有$符号（字符串终止符号）
<h3 id="database setup">database setup</h3>

<h3 id="shell">shell</h3>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>python manage.py shell
</blockquote></pre></div>
用作测试
<h3 id="view construct">view construct</h3>
<h4 id=" simple"> simple</h4>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>from django.http import HttpResponse

def detail(request, question_id):
    return HttpResponse(&quot;You&apos;re looking at question %s.&quot; % question_id)
</blockquote></pre></div>
<h4 id="template rendering">template rendering</h4>
采用模板导入

<h5 id="模板目录">模板目录</h5>

由于所有的template文件夹（如polls/templates）都实际上是同一级文件夹，所以最好再自己保持目录的有序性

比如polls/templates/polls/xxx.html
<h5 id="模板编写">模板编写</h5>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>{% if latest_question_list %}
    &lt;ul&gt;
    {% for question in latest_question_list %}
        &lt;li&gt;&lt;a href=&quot;/polls/{{ question.id }}/&quot;&gt;{{ question.question_text }}&lt;/a&gt;&lt;/li&gt;
    {% endfor %}
    &lt;/ul&gt;
{% else %}
    &lt;p&gt;No polls are available.&lt;/p&gt;
{% endif %}
</blockquote></pre></div>
<h5 id="模板实例化">模板实例化</h5>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>#polls/view.py
from django.http import HttpResponse
from django.template import loader

from .models import Question


def index(request):
    latest_question_list = Question.objects.order_by(&apos;-pub_date&apos;)[:5]
    template = loader.get_template(&apos;polls/index.html&apos;)
    context = {&apos;latest_question_list&apos;: latest_question_list,}
    return HttpResponse(template.render(context, request))
</blockquote></pre></div>
这样context中的json对应文件就会自动代入

或者使用简化的方法
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>from django.shortcuts import render

from .models import Question

def index(request):
    latest_question_list = Question.objects.order_by(&apos;-pub_date&apos;)[:5]
    context = {&apos;latest_question_list&apos;: latest_question_list}
    return render(request, &apos;polls/index.html&apos;, context)
</blockquote></pre></div>
<h5 id="404">404</h5><div class="liRank0"><li class="liRank0">raise Http404("404 imformation")__(自动return)__</li></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>from django.http import Http404
from django.shortcuts import render

from .models import Question

def detail(request, question_id):
    try:
        question = Question.objects.get(pk=question_id)
    except Question.DoesNotExist:
        raise Http404(&quot;Question does not exist&quot;)
    return render(request, &apos;polls/detail.html&apos;, {&apos;question&apos;: question})
</blockquote></pre></div><div class="liRank0"><li class="liRank0">get_object_or_404(Question, pk=question_id)</li></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>from django.shortcuts import get_object_or_404, render

from .models import Question

def detail(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    return render(request, &apos;polls/detail.html&apos;, {&apos;question&apos;: question})
</blockquote></pre></div>
<h4 id="模板文件url动态化">模板文件url动态化</h4>
<h5 id="直接处理">直接处理</h5>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>/polls/{{ question.id }}/
</blockquote></pre></div>
转化为（左边右边记得加符号）

<div class='codeBlock'><pre class='codeBlockPre'><blockquote>url &apos;detail&apos; question.id
</blockquote></pre></div>

也就是对于name=detail的ur解析响应 反向按照后面的参数导入正则表达式
<h5 id="url分类">url分类</h5>
在polls/url.py中添加
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>app_name = &apos;polls&apos;
</blockquote></pre></div>
则模板中可以使用
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>url &apos;polls:detail&apos; question.id
</blockquote></pre></div>
</div></body>
</html>
