<!DOCTYPE html>
<html>
<head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width"><link rel="stylesheet" type="text/css" media="all" href="../css/article_styles.css"><script type='text/x-mathjax-config'>  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script><script type='text/javascript' src='http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></head>
<body><div class='content'><h1 id="2018-2-6 JavaScript Note 7">2018-2-6 JavaScript Note 7</h1>
<h2 id="AJAX">AJAX</h2><div class='citation'><p class='citationP'><br>要让用户留在当前页面中，同时发出新的HTTP请求，就必须用JavaScript发送这个新请求，接收到数据后，再用JavaScript更新页面，这样一来，用户就感觉自己仍然停留在当前页面，但是数据却可以不断地更新。<br>最早大规模使用AJAX的就是Gmail，Gmail的页面在首次加载后，剩下的所有数据都依赖于AJAX来更新。<br>用JavaScript写一个完整的AJAX代码并不复杂，但是需要注意：AJAX请求是异步执行的，也就是说，要通过回调函数获得响应
</p></div>
在现代浏览器上写AJAX主要依靠XMLHttpRequest对象
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>function success(text) {
    var textarea = document.getElementById(&apos;test-response-text&apos;);
    textarea.value = text;
}

function fail(code) {
    var textarea = document.getElementById(&apos;test-response-text&apos;);
    textarea.value = &apos;Error code: &apos; + code;
}
//高版本浏览器
var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象
//低版本浏览器
//var request = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); // 新建Microsoft.XMLHTTP对象
request.onreadystatechange = function () { // 状态发生变化时，函数被回调
    if (request.readyState === 4) { // 成功完成
        // 判断响应结果:
        if (request.status === 200) {
            // 成功，通过responseText拿到响应的文本:
            return success(request.responseText);
        } else {
            // 失败，根据响应码判断失败原因:
            return fail(request.status);
        }
    } else {
        // HTTP请求还在继续...
    }
}

// 发送请求:
request.open(/*method*/&apos;GET&apos;, /*url*/&apos;/api/categories&apos;);
request.send(/*data*/);

alert(&apos;请求已发送，请等待响应...&apos;);

</blockquote></pre></div><div class="liRank0"><li class="liRank0">当创建了XMLHttpRequest对象后，要先设置onreadystatechange的回调函数。在回调函数中，通常我们只需通过readyState === 4判断请求是否完成，如果已完成，再根据status === 200判断是否是一个成功的响应。</li></div>
<div class="liRank0"><li class="liRank0">XMLHttpRequest对象的open()方法有3个参数，第一个参数指定是GET还是POST，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是true，所以不用写。</li></div>
<div class="liRank0"><li class="liRank0">注意，千万不要把第三个参数指定为false，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。</li></div>
<div class="liRank0"><li class="liRank0">最后调用send()方法才真正发送请求。GET请求不需要参数，POST请求需要把body部分以字符串或者FormData对象传进去。</li></div><div class="liRank0"><li class="liRank0">上面代码的URL使用的是 <strong>相对路径</strong> 。如果你把它改为```http://www.sina.com.cn/```，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。这是因为浏览器的同源策略导致的。<strong>默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致</strong>。完全一致的意思是，域名要相同（www.example.com和example.com不同），协议要相同（http和https不同），端口号要相同（默认是:80端口，它和:8080就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。</li></div>

那是不是用JavaScript无法请求外域（就是其他网站）的URL了呢？方法还是有的，大概有这么几种：

一是通过Flash插件发送HTTP请求，这种方式可以绕过浏览器的安全限制，但必须安装Flash，并且跟Flash交互。不过Flash用起来麻烦，而且现在用得也越来越少了。

二是通过在同源域名下架设一个代理服务器来转发，JavaScript负责把请求发送到代理服务器：

'/proxy?url=http://www.sina.com.cn'

代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。

第三种方式称为JSONP，它有个限制，只能用GET请求，并且要求返回JavaScript。这种方式跨域实际上是利用了浏览器允许跨域引用JavaScript资源：
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>&lt;html&gt;
&lt;head&gt;
    &lt;script src=&quot;http://example.com/abc.js&quot;&gt;&lt;/script&gt;
    ...
&lt;/head&gt;
&lt;body&gt;
...
&lt;/body&gt;
&lt;/html&gt;
</blockquote></pre></div>
这样一来，我们如果在页面中先准备好foo()函数，然后给页面动态加一个<script>节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了<div class="liRank0"><li class="liRank0">首先在页面中准备好回调函数</li></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>function refreshPrice(data) {
    var p = document.getElementById(&apos;test-jsonp&apos;);
    p.innerHTML = &apos;当前价格：&apos; +
        data[&apos;0000001&apos;].name +&apos;: &apos; + 
        data[&apos;0000001&apos;].price + &apos;；&apos; +
        data[&apos;1399001&apos;].name + &apos;: &apos; +
        data[&apos;1399001&apos;].price;
}
</blockquote></pre></div><div class="liRank0"><li class="liRank0">接下来调用</li></div>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>function getPrice() {
    var
        js = document.createElement(&apos;script&apos;),
        head = document.getElementsByTagName(&apos;head&apos;)[0];
    js.src = &apos;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&apos;;
    head.appendChild(js);
}
</blockquote></pre></div>
则会访问http://api.money.126.net/data/feed/0000001,1399001，将返回的数据以refreshPrice（prop)执行
<h3 id="延时异步执行">延时异步执行</h3>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>setTimeout(var_function,var_time_msec,var_para_of_var_function)
</blockquote></pre></div>
<h3 id="Promise对象">Promise对象</h3>
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>//等效于上面的AJAX直接修改
var ajax = ajaxGet(&apos;http://...&apos;);
ajax.ifSuccess(success)
    .ifFail(fail);
</blockquote></pre></div>
可以用Promise实现
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>function test(resolve,reject){
  ...
  if(...){
    resolve(&quot;success message&quot;);
  }else{
    reject(&quot;reject message&quot;);
  }
}
var p=new Promise(test).then(function(msg){;}).catch(function(msg){;});
</blockquote></pre></div>
<div class="image"><image src="assets/2018-2-6_JavaScript_Note_7-d26f0.png" title=""></image></div>
要串行执行这样的异步任务，不用Promise需要写一层一层的嵌套代码。有了Promise，我们只需要简单地写：
<div class='codeBlock'><pre class='codeBlockPre'><blockquote>job1.then(job2).then(job3).catch(handleError);
</blockquote></pre></div>
<h4 id="其他">其他</h4><div class="ulRank0"><ul class="ulRank0">1. 并行</ul></div>
Promise.all([p1,p2]).then(...)<div class="ulRank0"><ul class="ulRank0">2. 同时进行只需要一个完成</ul></div>
Promise.race([p1,p2]).then(...)</div></body>
</html>
