# 散列
* call by value
* 使用场景:数据来自很大的范围但是非常稀疏
* 目标:压缩空间
* 实现思路:value经过hashfunction转化为对应的bucket（O(1)），然后在bucket中搜索
## 实现
hash(key)=key%M
* 装填因子$LoadFactor=\frac{N}{M}$
## 冲突
无法避免
* __更好的散列函数__
1. 确定(determinism)
2. 快速(efficiency)
3. 均匀(surjection)
4. 满射(uniformity)
* __散列函数__

| 方法     | 示意                  | 说明                   | 补充                                                                |
|:---------|:----------------------|:-----------------------|:--------------------------------------------------------------------|
| 模余法   | hash(key)=key%M       | M 为素数(覆盖充分均匀) | 存在不动点，零阶均匀                                                |
| MAD法    | hash(key)=(key*a+b)%M | M为素数,a mod M!=0     | 一阶均匀                                                            |
| 平方取中 | 取平方居中的几个数位k |                        |                                                                     |
| 折叠汇总 | 压位运算              |                        | 中间的压位数字可以有不同的读取方法:不同进制，不同位数，不同读取方向 |

* 伪随机数
* hashcode
1. 数字
1. 字符串：多项式法

计算复杂度O(n)

近似算法

## 排解冲突
* 多槽位法



* 多链表法
列表存放冲突词条
Open Hashing
/
Close Addressing

| Open Hashing                                                | Close Hashing |
|:------------------------------------------------------------|:--------------|
| 空间不能封闭，可能动态增长且列表跳转导致的重新cache开销过大 | 桶长固定      |

| Open Addressing    | Closeng Addressing |
|:-------------------|:-------------------|
| 同族可以在不同桶中 | 同族在同一桶中     |

* __线性试探（Linear probing）__

轮番质询邻居桶
Close Hashing
/
Open Addressing
1. 查找：从原位置开始依次查找直到有未使用过的空桶或找到目标元素
1. 插入：从原位置开始依次查找直到有空桶，放入
1. 删除：标记曾经使用过再删除


1. 冲突累计效应
1. cache利用效率高


* __平方试探（Quadratic probing）__：移动步长随冲突次数而增加
\[
[hash(key)+k^2] mod M
\]
可能找不到

装填因子不能过高（50%以下）
* __双向平方试探（Biquadratic probing）__

表长需要选模4余3的素数
>费马双平方定理：

若 $\exists$ x,y ,使素数z=x^2+y^2 则z =1 (mod 4)

* __rehash__

## 桶排序(BucketSort)
预先分配桶
## 基数排序(RadixSort)
按照数位排序
## 计数排序(CountingSort)

## 跳转表
