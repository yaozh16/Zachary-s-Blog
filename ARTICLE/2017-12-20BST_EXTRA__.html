<!DOCTYPE html>
<html>
<head><meta http-equiv="content-type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width"><link rel="stylesheet" type="text/css" media="all" href="../css/article_styles.css"><script type='text/x-mathjax-config'>  MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script><script type='text/javascript' src='http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script></head>
<body><div class='content'><h2 id="MLST">MLST</h2>
用于range查找

思路：先以x为key建立线段树，x线段树的内容是以y为key的由点组成的BST
<div class="ulRank0"><ul class="ulRank0">1. 构造时间复杂度</ul></div>

每个节点在h=logn个x线段树节点（y树）中出现
<div class="liRank0"><li class="liRank0">插入时间复杂度</li></div>

\[
T(n)=logn+log\frac{n}{2}+log\frac{n}{4}+……+log1
\]\[
2T(n)=logn\times logn
\]\[
T(n)=O(log^2n)
\]<div class="liRank0"><li class="liRank0">插入完成后对每一个x节点(y树)的预处理</li></div>

遍历一次所有x节点（y树）,总计
\[
O(nlogn)
\]<div class="ulRank0"><ul class="ulRank0">2. 查询时间复杂度</ul></div>

在高度k的x节点停止时，对应的该节点大小为 $2^h$ 在此区间中以及之后的部分才是需要进一步查找的，总共是

<table cellspacing='0'><tr><th>$2^h$</th><th>$2^{h+1}$</th><th>$2^{h+1}$</th><th>...</th><th> $2^{k+1}$ </th><th> $2^k$</th></tr></table><br>
分别对y进行查找
\[
\Sigma{logL_i}=O(h+(h+1)+...+k)
\le 1+2+3+...+(logn-2)+(logn-2)+...+1=(logn-2)(logn-1)=O(log^2n)
\]

遍历:
$O(r)$

<h2 id="改进:RangeTree （用建树时间增加换取搜索时间大大减少）">改进:RangeTree （用建树时间增加换取搜索时间大大减少）</h2><div class="ulRank0"><ul class="ulRank0">1. 先对y排序放入根节点</ul></div>
\[
O(nlogn)
\]<div class="ulRank0"><ul class="ulRank0">2. 再对每个x线段节点的ylist的节点 $O(len(SubTree_i))$ ,找到x线段节点的左右孩子的ylist的相应的位置（这里相应表示被指的数大于或者等于原节点）</ul></div>
\[
\Sigma len(SubTree_i)=O(nlogn)
\]
（等效于树中每个基本节点被遍历一次）<div class="ulRank0"><ul class="ulRank0">3. 搜索：先一次搜索得到前后哨兵后(2logn)，时刻牵住这个位置，对x进行平移（最坏logn）</ul></div>

<h2 id="TournamentTree">TournamentTree</h2>
<h2 id="LoserTree">LoserTree</h2>
<h2 id="d-heap">d-heap</h2>
与BTree类似
</div></body>
</html>
